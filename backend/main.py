"""
Demucs Audio Separation API

REST API for uploading audio files, processing them with Demucs,
and downloading the separated tracks.
"""

import asyncio
import logging
import os
import shutil
import subprocess
import uuid
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Dict, Optional

import aiofiles
from fastapi import FastAPI, File, HTTPException, UploadFile, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, JSONResponse
from pydantic import BaseModel

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Directories
UPLOAD_DIR = Path("/app/uploads")
TEMP_DIR = Path("/app/temp")
COMPLETED_DIR = Path("/app/completed")

# Ensure directories exist
UPLOAD_DIR.mkdir(exist_ok=True)
TEMP_DIR.mkdir(exist_ok=True)
COMPLETED_DIR.mkdir(exist_ok=True)

# Initialize FastAPI app
app = FastAPI(
    title="Demucs Audio Separation API",
    description="Upload audio files and separate them into individual tracks (vocals, drums, bass, other)",
    version="1.0.0"
)

# Add CORS middleware to allow frontend access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins (restrict in production)
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


class JobStatus(str, Enum):
    """Job processing status"""
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    FAILED = "failed"


class Job(BaseModel):
    """Job information"""
    job_id: str
    status: JobStatus
    filename: str
    created_at: str
    completed_at: Optional[str] = None
    error: Optional[str] = None
    download_url: Optional[str] = None


# In-memory job storage (use Redis/DB in production)
jobs: Dict[str, Job] = {}


async def process_audio_file(job_id: str, input_path: Path):
    """
    Background task to process audio file with Demucs.
    
    Args:
        job_id: Unique job identifier
        input_path: Path to uploaded audio file
    """
    job = jobs.get(job_id)
    if not job:
        logger.error(f"Job {job_id} not found")
        return
    
    try:
        # Update status to processing
        job.status = JobStatus.PROCESSING
        logger.info(f"Starting demucs processing for job {job_id}")
        
        # Create output directory for this job
        output_dir = TEMP_DIR / job_id
        output_dir.mkdir(exist_ok=True)
        
        # Run demucs command
        # Default model is 'htdemucs' (high-quality)
        # Output format: separated/htdemucs/<song_name>/{drums,bass,other,vocals}.wav
        cmd = [
            "demucs",
            "--two-stems=vocals",  # Remove this to get all 4 stems
            "--out", str(output_dir),
            "--mp3",  # Output as MP3
            "--mp3-bitrate", "320",
            str(input_path)
        ]
        
        # For all 4 stems (drums, bass, other, vocals), use this instead:
        cmd_all_stems = [
            "demucs",
            "--out", str(output_dir),
            "--mp3",
            "--mp3-bitrate", "320",
            str(input_path)
        ]
        
        # Use all stems command
        process = await asyncio.create_subprocess_exec(
            *cmd_all_stems,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        
        if process.returncode != 0:
            error_msg = stderr.decode() if stderr else "Unknown error"
            logger.error(f"Demucs failed for job {job_id}: {error_msg}")
            job.status = JobStatus.FAILED
            job.error = error_msg
            return
        
        logger.info(f"Demucs processing completed for job {job_id}")
        
        # Find the output directory (demucs creates htdemucs/<filename_without_ext>/)
        demucs_output = output_dir / "htdemucs"
        if not demucs_output.exists():
            raise FileNotFoundError(f"Demucs output directory not found: {demucs_output}")
        
        # Get the first subdirectory (song name)
        song_dirs = list(demucs_output.iterdir())
        if not song_dirs:
            raise FileNotFoundError("No output files generated by Demucs")
        
        song_dir = song_dirs[0]
        
        # Create ZIP file
        zip_filename = f"{job_id}.zip"
        zip_path = COMPLETED_DIR / zip_filename
        
        logger.info(f"Creating ZIP archive for job {job_id}")
        
        # Use shutil.make_archive to create ZIP
        shutil.make_archive(
            str(zip_path.with_suffix('')),  # base name without extension
            'zip',
            song_dir  # directory to archive
        )
        
        # Clean up temp files
        shutil.rmtree(output_dir)
        input_path.unlink()
        
        # Update job status
        job.status = JobStatus.COMPLETED
        job.completed_at = datetime.utcnow().isoformat()
        job.download_url = f"/download/{job_id}"
        
        logger.info(f"Job {job_id} completed successfully")
        
    except Exception as e:
        logger.exception(f"Error processing job {job_id}")
        job.status = JobStatus.FAILED
        job.error = str(e)
        
        # Clean up on error
        try:
            if input_path.exists():
                input_path.unlink()
            temp_output = TEMP_DIR / job_id
            if temp_output.exists():
                shutil.rmtree(temp_output)
        except Exception as cleanup_error:
            logger.error(f"Error during cleanup: {cleanup_error}")


@app.get("/")
async def root():
    """Health check endpoint"""
    return {
        "service": "Demucs Audio Separation API",
        "status": "running",
        "version": "1.0.0"
    }


@app.post("/upload", response_model=Job)
async def upload_audio(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...)
):
    """
    Upload an audio file for processing.
    
    Args:
        file: Audio file (MP3, WAV, FLAC, etc.)
        
    Returns:
        Job information with job_id for tracking
    """
    # Validate file
    if not file.filename:
        raise HTTPException(status_code=400, detail="No filename provided")
    
    # Check file extension
    allowed_extensions = {'.mp3', '.wav', '.flac', '.ogg', '.m4a', '.aac'}
    file_ext = Path(file.filename).suffix.lower()
    if file_ext not in allowed_extensions:
        raise HTTPException(
            status_code=400,
            detail=f"Unsupported file type. Allowed: {', '.join(allowed_extensions)}"
        )
    
    # Generate unique job ID
    job_id = str(uuid.uuid4())
    
    # Save uploaded file
    upload_path = UPLOAD_DIR / f"{job_id}{file_ext}"
    
    try:
        async with aiofiles.open(upload_path, 'wb') as f:
            content = await file.read()
            await f.write(content)
        
        logger.info(f"File uploaded: {file.filename} -> {upload_path}")
        
    except Exception as e:
        logger.exception("Error saving uploaded file")
        raise HTTPException(status_code=500, detail=f"Failed to save file: {str(e)}")
    
    # Create job
    job = Job(
        job_id=job_id,
        status=JobStatus.PENDING,
        filename=file.filename,
        created_at=datetime.utcnow().isoformat()
    )
    jobs[job_id] = job
    
    # Start background processing
    background_tasks.add_task(process_audio_file, job_id, upload_path)
    
    logger.info(f"Job {job_id} created and queued for processing")
    
    return job


@app.get("/status/{job_id}", response_model=Job)
async def get_job_status(job_id: str):
    """
    Get the status of a processing job.
    
    Args:
        job_id: Job identifier
        
    Returns:
        Job information including status and download URL if completed
    """
    job = jobs.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")
    
    return job


@app.get("/download/{job_id}")
async def download_result(job_id: str):
    """
    Download the processed audio tracks as a ZIP file.
    
    Args:
        job_id: Job identifier
        
    Returns:
        ZIP file containing separated audio tracks
    """
    job = jobs.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")
    
    if job.status != JobStatus.COMPLETED:
        raise HTTPException(
            status_code=400,
            detail=f"Job is not completed yet. Current status: {job.status}"
        )
    
    zip_path = COMPLETED_DIR / f"{job_id}.zip"
    if not zip_path.exists():
        raise HTTPException(status_code=404, detail="Result file not found")
    
    return FileResponse(
        path=zip_path,
        filename=f"{Path(job.filename).stem}_separated.zip",
        media_type="application/zip"
    )


@app.delete("/job/{job_id}")
async def delete_job(job_id: str):
    """
    Delete a job and its associated files.
    
    Args:
        job_id: Job identifier
        
    Returns:
        Success message
    """
    job = jobs.get(job_id)
    if not job:
        raise HTTPException(status_code=404, detail="Job not found")
    
    # Delete files
    zip_path = COMPLETED_DIR / f"{job_id}.zip"
    if zip_path.exists():
        zip_path.unlink()
    
    # Remove from jobs dict
    del jobs[job_id]
    
    logger.info(f"Job {job_id} deleted")
    
    return {"message": "Job deleted successfully"}


@app.get("/jobs")
async def list_jobs():
    """
    List all jobs.
    
    Returns:
        List of all jobs
    """
    return {"jobs": list(jobs.values())}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=80)
